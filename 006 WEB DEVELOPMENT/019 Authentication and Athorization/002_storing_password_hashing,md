# Storing Passwords Securely in Node.js

This document explains how to store user passwords safely in a Node.js application using secure hashing functions. It includes best practices, short explanations, and working code examples using bcrypt and argon2.

⸻

### Why you must hash (not encrypt) passwords
-	Hashing is a one-way operation: you cannot recover the original password from the hash.
-	Encryption is reversible (requires a key) and is not appropriate for primary password storage.
-	Always use a slow, memory- or CPU-hard hashing algorithm (e.g., bcrypt, argon2) with a unique salt per password.

⸻

Best practices
	•	Use bcrypt or argon2 (argon2id recommended) for new projects.
	•	Use a unique salt per password — these libraries handle it for you.
	•	Choose an appropriate work factor/cost and test performance on your hardware.
	•	Use HTTPS/TLS for all network traffic to and from your server.
	•	Apply rate-limiting and account lockouts to slow brute-force attacks.
	•	Store only the hash (and any metadata like algorithm and cost) in the database.
	•	Consider a server-side pepper (an application-level secret) only if you can securely rotate it.
	•	Plan a migration path for algorithm/parameter upgrades (store algorithm version with each hash).

⸻

Example 1 — Using bcrypt (simple and common)

#### Install
``` bash
npm install bcrypt
```
#### Create a new user (hashing on signup)
```js
// signup.js
const bcrypt = require('bcrypt');

async function hashPassword(plainPassword) {
  const saltRounds = 12; // adjust based on your performance tests
  const hash = await bcrypt.hash(plainPassword, saltRounds);
  return hash; // store this in DB
}
```
// usage
// const hashed = await hashPassword('userPassword123');

Verify user (login)

async function verifyPassword(plainPassword, userHash) {
  const match = await bcrypt.compare(plainPassword, userHash);
  return match; // true or false
}

Notes: bcrypt.hash generates and uses a random salt automatically and embeds it in the result.

⸻

Example 2 — Using argon2 (modern, memory-hard)

Install

npm install argon2

Hashing and verification

const argon2 = require('argon2');

async function hashPasswordArgon2(password) {
  // argon2id is a good general-purpose choice
  return await argon2.hash(password, { type: argon2.argon2id });
}

async function verifyArgon2(password, hash) {
  try {
    if (await argon2.verify(hash, password)) {
      return true;
    }
  } catch (err) {
    // verify throws if hash is malformed
  }
  return false;
}

Argon2 enables tuning memory, time, and parallelism parameters. Test them to balance security and server performance.

⸻

Storing metadata and migration strategy

Store alongside the hash: algorithm name (bcrypt/argon2), cost/work factor, and a version number. That lets you gradually re-hash passwords when users next log in (transparent migration).

Example DB fields:
	•	password_hash — the hash string
	•	hash_algo — e.g., argon2id
	•	hash_params — JSON or a string with config (e.g., salt length, cost)
	•	hash_version — integer for migrations

When a user logs in and you detect an older/weak algorithm or cost, verify the password, then re-hash with the new algorithm/params and update the DB.

⸻

Additional security tips
	•	Protect your database and limit access to the password hash column.
	•	Monitor for data breaches and have a plan (force password resets if necessary).
	•	Use multi-factor authentication (MFA) to reduce risk even if passwords leak.
	•	Do not log unhashed passwords or send them in plain text to third parties.

⸻

Quick checklist before launch
	•	Use HTTPS
	•	Choose bcrypt or argon2 and tune parameters
	•	Implement rate-limiting and lockout policies
	•	Store algorithm metadata for migration
	•	Consider adding MFA

⸻

References & further reading

(Keep internal notes or links to the libraries’ docs and security articles handy.)

⸻

End of document.